#!/usr/bin/env perl
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2022 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#

use strict;
use warnings;

use DateTime::Format::ISO8601;
use Getopt::Long;
use XML::LibXML;

my $v;
my @opdefs;

GetOptions
    (
     'verbose|v' => \$v,
     'trkseg-split-by-time=i' => sub {
	 my $delta_time = $_[1];
	 push @opdefs, { op => 'trkseg_split_by_time', args => [$delta_time] };
     },
    )
    or die "usage?";
my $file = shift;
@ARGV and die "usage?";

my @load_xml_opts;
if ($file && $file ne '-') {
    @load_xml_opts = (location => $file);
} else {
    @load_xml_opts = (IO => \*STDIN);
}

my $doc = XML::LibXML->load_xml(@load_xml_opts);

for my $opdef (@opdefs) {
    no strict 'refs';
    &{$opdef->{op}}(@{ $opdef->{args} });
}

print $doc->toString;

sub trkseg_split_by_time {
    my($delta_time) = @_;
    for my $trk ($doc->findnodes('/*[local-name(.)="gpx"]/*[local-name(.)="trk"]')) {
	for my $trkseg ($trk->findnodes('./*[local-name(.)="trkseg"]')) {
	    my($prev_trkpt) = $trkseg->findnodes('(./*[local-name(.)="trkpt"])[1]');
	    while (my $next_trkpt = $prev_trkpt->nextNonBlankSibling) {
		# XXX do we need to check if $next_trkpt is really a trkpt?
		my $this_delta_time = trkpt_delta_time($prev_trkpt, $next_trkpt);
		if ($this_delta_time >= $delta_time) {
		    warn "Need to split between " . trkpt_label($prev_trkpt) . " and " . trkpt_label($next_trkpt) . ".\n" if $v;
		    my $new_trkseg = $doc->createElement('trkseg');
		    $trk->insertBefore($new_trkseg, $trkseg);
		    my($node_to_move) = $trkseg->findnodes('(./*[local-name(.)="trkpt"])[1]');
		    while($node_to_move != $next_trkpt) {
			my $next_node = $node_to_move->nextSibling;
			$new_trkseg->addChild($node_to_move);
			$node_to_move = $next_node;
		    }
		}
		$prev_trkpt = $next_trkpt;
	    }
	}
    }
}

sub trkpt_delta_time {
    my($prev_trkpt, $next_trkpt) = @_;
    my $prev_time = DateTime::Format::ISO8601->parse_datetime($prev_trkpt->findvalue('./*[local-name(.)="time"]'));
    my $next_time = DateTime::Format::ISO8601->parse_datetime($next_trkpt->findvalue('./*[local-name(.)="time"]'));
    $next_time->epoch - $prev_time->epoch;
}

sub trkpt_label {
    my($trkpt) = @_;
    $trkpt->findvalue('./*[local-name(.)="time"]');
}

__END__
