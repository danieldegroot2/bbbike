# Sample config file for converted osm data

require FindBin;
my $BBBIKE_ROOT = "$FindBin::RealBin/..";

#@Strassen::datadirs = ("/tmp/data_dalmatien"); # set here directory with converted osm data - see osm2bbd
@Strassen::datadirs = ("/tmp/data_osm"); # set here directory with converted osm data - see osm2bbd
@PLZ::plzfile       = ("/nonexistent");

$PLZ::OLD_AGREP = $Strassen::OLD_AGREP = 1;

$debug = 1;
$VERBOSE = 1; # funktioniert nicht mit FCGI

#$can_mapserver = 1;
#$mapserver_prog_relurl = "/cgi-bin/mapserv";
## Cannot use $ENV{SERVER_NAME} because it is also called offline for mapserver template generation
#$mapserver_prog_url = "http://localhost$mapserver_prog_relurl";
#$mapserver_dir = "$BBBIKE_ROOT/mapserver/brb";
#$bbd2esri_prog = "$BBBIKE_ROOT/miscsrc/bbd2esri";
$use_utf8 = 1;

# Enable the following if the osm data was built with wgs84
# coordinates. Note that this is dangerous in mod_perl operation, as
# it changes subroutine definitions globally!
if (1) {
    no warnings 'redefine';

    require Strassen::Util;
    *Strassen::Util::strecke   = \&Strassen::Util::strecke_polar;
    *Strassen::Util::strecke_s = \&Strassen::Util::strecke_s_polar;
    if (defined &StrassenNetz::make_net_PP) {
	*StrassenNetz::make_net = \&StrassenNetz::make_net_PP;
    }

    require BBBikeDraw;
    *BBBikeDraw::create_transpose = sub {
    my($self, %args) = @_;
    require Karte::Polar;
    require Karte::Standard;
    my($w, $h) = ($self->{Width}, $self->{Height});
    my($min_x, $min_y, $max_x, $max_y) =
      ($Karte::Polar::obj->map2standard($self->{Min_x}, $self->{Min_y}),
       $Karte::Polar::obj->map2standard($self->{Max_x}, $self->{Max_y}));
    my($xk, $yk) = ($w/($max_x-$min_x), $h/($max_y-$min_y));
    my $aspect = ($max_x-$min_x)/($max_y-$min_y);
    my($delta_x, $delta_y) = ($min_x, $min_y);
    if ($aspect < $w/$h) {
	$xk *= $aspect/($w/$h);
	$delta_x -= ($w/$xk-$max_x+$min_x)/2;
    } else {
	$yk /= $aspect/($w/$h);
	$delta_y -= ($h/$yk-$max_y+$min_y)/2;
    }

    my($transpose, $anti_transpose);

    my($code, $anti_code);
    if ($self->origin_position eq 'sw') {
	# Ursprung ist unten, nicht oben (z.B. PDF)
	$code = <<EOF;
	sub {
	    my(\$x,\$y) = \$Karte::Polar::obj->map2standard(\@_);
	    ((\$x-$delta_x)*$xk, (\$y-$delta_y)*$yk);
	};
EOF
        $code =~ s/--/+/g;
	$code =~ s/\+-/-/g;
	#warn $code;
	$transpose = eval $code;
	die "$code: $@" if $@;

	$anti_code = <<EOF;
	sub {
	    my(\$x,\$y) = ((\$_[0]/$xk)+$delta_x, (\$_[1]/$yk)+$delta_y);
	    \$Karte::Polar::obj->standard2map(\$x,\$y);
	};
EOF
        $anti_code =~ s/--/+/g;
	$anti_code =~ s/\+-/-/g;
	#warn $anti_code;
        $anti_transpose = eval $anti_code;
	die "$anti_code: $@" if $@;
    } else { # origin_positon eq 'nw'
	$code = <<EOF;
	sub {
	    my(\$x,\$y) = \$Karte::Polar::obj->map2standard(\@_);
	    ((\$x-$delta_x)*$xk, $h-(\$y-$delta_y)*$yk);
	};
EOF
        $code =~ s/--/+/g;
	$code =~ s/\+-/-/g;
        $transpose = eval $code;
	die "$code: $@" if $@;

	$anti_code = <<EOF;
	sub {
	    my(\$x,\$y) = ((\$_[0]/$xk)+$delta_x, ($h-\$_[1])/$yk+$delta_y);
	    \$Karte::Polar::obj->standard2map(\$x,\$y);
	};
EOF
        $anti_code =~ s/--/+/g;
	$anti_code =~ s/\+-/-/g;
        $anti_transpose = eval $anti_code;
	die "$anti_code: $@" if $@;
    }

    $self->{Transpose}     = $transpose;
    $self->{AntiTranspose} = $anti_transpose;

    if ($args{-asstring}) {
	$self->{TransposeCode}     = $code;
	$self->{AntiTransposeCode} = $anti_code;
    }

#XXX does not work here!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#    $self->{TransposeJS} = _transpose_perl_to_js($code);
    # warn $self->{TransposeJS};

    # Correct bounding box:
    #warn "before: $self->{Min_x},$self->{Min_y} $self->{Max_x},$self->{Max_y}";
    $self->set_bbox($anti_transpose->(0,0),$anti_transpose->($w, $h));
    #warn "after: $self->{Min_x},$self->{Min_y} $self->{Max_x},$self->{Max_y}";

    # Bei 100dpi ist Xk=1 <=> 1km=1000 Pixel
    $self->{Xk} = $xk;
    $self->{Yk} = $yk;
};

}

1; # may be required
